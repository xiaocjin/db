进阶
====

##事务

###概述

  Redis 中的事务（ transaction） 是一组命令的集合。
  事务同命令一样都是 Redis 的最小执行单位，一个事务中的命令要么都执行，要么都不执行。
  
    redis ＞ MULTI 
    OK 
    redis ＞ SADD   "user: 1: following"   2 
    QUEUED 
    redis ＞ SADD   "user: 2: followers"   1 
    QUEUED 
    redis ＞ EXEC 
    1)   (integer)  
    2)   (integer)
  
###错误处理
1. 语法错误——不执行事务
2. 运行错误——如果事务里的一条命令出现了运行错误，事务里其他的命令依然会继续执行

###WATCH命令
  WATCH 命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到 EXEC 命令。
  由于 WATCH 命令的作用只是当被监控的键值被修改后阻止之后一个事务的执行，而不能保证其他客户端不修改这一键值，所以我们需要在 EXEC 执行失败后重新执行整个函数。

##生存时间

###EXPIRE命令
  在 Redis 中可以使用 EXPIRE 命令设置一个键的生存时间，到时间后 Redis 会自动删除它。
  如果想知道一个键还有多久的时间会被删除，可以使用 TTL 命令。
  如果想取消键的生存时间设置（即将键恢复成永久的），可以使用 PERSIST 命令。
  除了 PERSIST 命令之外，使用 SET 或 GETSET 命令为键赋值也会同时清除键的生存时间，使用 EXPIRE 命令会重新设置键的生存时间，其他只对键值进行操作的命令（如 INCR、 LPUSH、 HSET、 ZREM） 均不会影响键的生存时间。

##排序

###方法
1. 有序集合的集合操作
2. SORT命令——对列表类型、集合类型和有序集合类型键进行排序
3. By参数
4. Get参数
5. STORE参数

###优化
  SORT 是 Redis 中最强大最复杂的命令之一，如果使用不好很容易成为性能瓶颈。 SORT 命令的时间复杂度是 0(n + mlogm)， 其中 n 表示要排序的列表（集合或有序集合）中的元素个数， m 表示要返回的元素个数。当 n 较大的时候 SORT 命令的性能相对较低，并且 Redis 在排序前会建立一个长度为 n 的容器来存储待排序的元素，虽然是一个临时的过程，但如果同时进行较多的大数据量排序操作则会严重影响性能。
  
  1. 尽可能减少待排序键中元素的数量（使 n 尽可能小）。
  2. 使用 LIMIT 参数只获取需要的数据（使 m 尽可能小）。
  3. 如果要排序的数据数量较大，尽可能使用 STORE 参数将结果缓存。

##消息通知

###任务队列
  与任务队列进行交互的实体有两类，一类是生产者（ producer）， 一类是消费者（ consumer）。 生产者会将需要处理的任务放入任务队列中，而消费者则不断地从任务队列中读入任务信息并执行。
  
  * 松耦合。生产者和消费者无需知道彼此的实现细节，只需要约定好任务的描述格式。这使得生产者和消费者可以由不同的团队使用不同的编程语言编写。
  * 易于扩展消费者可以有多个，而且可以分布在不同的服务器中，如图 4-1 所示。借此可以轻易地降低单台服务器的负载。

###使用Redis实现的任务队列
###优先级队列
###发布/订阅模式
###按照规则订阅

##管道
  Redis 的底层通信协议对管道（ pipelining） 提供了支持。通过管道可以一次性发送多条命令并在执行完后一次性将结果返回，当一组命令中每条命令都不依赖于之前命令的执行结果时就可以将这组命令一起通过管道发出。管道通过减少客户端与 Redis 的通信次数来实现降低往返时延累。

